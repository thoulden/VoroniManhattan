<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Manhattan Voronoi (L1 / L2)</title>
<style>
  :root { --bg:#f8f7f2; --fg:#111; --accent:#0b6; }
  * { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

  /* Two-row grid: header then the canvas taking all remaining space */
  body {
    display: grid;
    grid-template-rows: auto 1fr;
    grid-template-columns: 100%;
  }

  header { padding: 10px 16px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  header > * { font-size: 14px; }
  label { display:inline-flex; align-items:center; gap:6px; }
  button { padding:6px 10px; border:1px solid #ccc; background:#fff; border-radius:8px; cursor:pointer; }
  button:hover { border-color: var(--accent); }

  /* Canvas wrapper fills the remaining row */
  #canvasWrap { position: relative; width: 100%; height: 100%; }
  #c { width: 100%; height: 100%; display:block; background: var(--bg); }

  #status { text-align:center; padding: 6px 0 12px; font-size: 13px; color:#666; }
</style>
</head>
<body>
  <header>
    <strong>Manhattan Voronoi</strong>
    <label>Metric:
      <select id="metric">
        <option value="l1" selected>Manhattan (L1)</option>
        <option value="l2">Euclidean (L2)</option>
      </select>
    </label>
    <label id="angleWrap">L1 angle:
      <input id="angle" type="range" min="-45" max="45" step="1" value="29" />
      <span id="angleVal">29°</span>
    </label>
    <label>Resolution (px):
      <select id="res">
        <option value="2" selected>Fast (2)</option>
        <option value="1">Fine (1)</option>
        <option value="3">Faster (3)</option>
        <option value="4">Fastest (4)</option>
      </select>
    </label>
    <button id="redraw">Redraw</button>
  </header>

  <div id="canvasWrap">
    <canvas id="c"></canvas>
  </div>
  <div id="status">Loading…</div>

<script type="module">
async function main() {
  const status = document.getElementById('status');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { willReadFrequently: false });

  const metricEl = document.getElementById('metric');
  const angleWrap = document.getElementById('angleWrap');
  const angleEl = document.getElementById('angle');
  const angleVal = document.getElementById('angleVal');
  const resEl = document.getElementById('res');
  const redrawBtn = document.getElementById('redraw');

  // Load data
  const [boundaryFC, stationsFC] = await Promise.all([
    fetch('./data/manhattan_boundary.geojson').then(r => r.json()),
    fetch('./data/manhattan_stations.geojson').then(r => r.json())
  ]);

  // GeoJSON helpers
  const fcToPolysLonLat = (fc) => {
    const polys = [];
    for (const feat of fc.features) {
      const g = feat.geometry;
      if (!g) continue;
      if (g.type === 'Polygon') polys.push(g.coordinates[0]);
      else if (g.type === 'MultiPolygon') for (const p of g.coordinates) polys.push(p[0]);
    }
    return polys;
  };
  const fcToPointsLonLat = (fc) => {
    const pts = [];
    for (const feat of fc.features) {
      const g = feat.geometry;
      if (g?.type === 'Point') pts.push(g.coordinates);
      else if (g?.type === 'MultiPoint') for (const p of g.coordinates) pts.push(p);
      // ignore others
    }
    return pts.map(([lon,lat]) => [lon,lat]);
  };

  // Spherical mercator (minimally safeguarded)
  function mercatorProject(lon, lat) {
    const λ = lon * Math.PI/180;
    const φ = Math.max(Math.min(lat * Math.PI/180, Math.PI/2 - 1e-6), -Math.PI/2 + 1e-6);
    return [λ, Math.log(Math.tan(Math.PI/4 + φ/2))];
  }

  // High-DPI sizing
  function resizeCanvasToDisplaySize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();          // CSS px
    const w = Math.max(1, Math.round(rect.width * dpr));  // backing px
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    // draw in CSS pixels by scaling once
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    status.textContent = `Canvas: CSS ${Math.round(rect.width)}×${Math.round(rect.height)} | Backing ${w}×${h} | DPR ${dpr.toFixed(2)}`;
  }

  // Data in lon/lat
  const ringsLonLat = fcToPolysLonLat(boundaryFC);
  const stationsLonLat = fcToPointsLonLat(stationsFC);

  // Derived (depends on size)
  let projectedRings = [];
  let toCanvas = (xy) => xy;
  let stationXY = [];

  function fitProjectionAndPrecompute() {
    projectedRings = ringsLonLat.map(r => r.map(([lon,lat]) => mercatorProject(lon,lat)));

    // bounds in projected space
    let minX=+Infinity, minY=+Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const ring of projectedRings) {
      for (const [x,y] of ring) {
        if (x<minX) minX=x; if (x>maxX) maxX=x;
        if (y<minY) minY=y; if (y>maxY) maxY=y;
      }
    }
    const pad = 0.04; minX -= pad; maxX += pad; minY -= pad; maxY += pad;

    // CSS size
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;

    const sx = cssW / (maxX - minX);
    const sy = cssH / (maxY - minY);
    const s  = Math.min(sx, sy);
    const ox = (cssW - s*(maxX-minX))/2;
    const oy = (cssH - s*(maxY-minY))/2;

    toCanvas = ([x,y]) => [ ox + s*(x - minX), oy + s*(maxY - y) ];
    stationXY = stationsLonLat.map(([lon,lat]) => toCanvas(mercatorProject(lon,lat)));
  }

  // Distances
  const palette = Array.from({length: 20}, (_,i) => `hsl(${(i*360/20)|0} 70% 45%)`);
  const rotate = (x,y,deg) => {
    const t = deg*Math.PI/180, c=Math.cos(t), s=Math.sin(t);
    return [ c*x + s*y, -s*x + c*y ];
  };
  function nearestIndexL1(x,y,deg=0) {
    if (deg) [x,y] = rotate(x,y,deg);
    let best=Infinity, idx=0;
    for (let i=0;i<stationXY.length;i++){
      let [sx,sy] = stationXY[i];
      if (deg) [sx,sy] = rotate(sx,sy,deg);
      const d = Math.abs(x-sx) + Math.abs(y-sy);
      if (d<best){best=d; idx=i;}
    }
    return idx;
  }
  function nearestIndexL2(x,y) {
    let best=Infinity, idx=0;
    for (let i=0;i<stationXY.length;i++){
      const [sx,sy] = stationXY[i];
      const dx=x-sx, dy=y-sy, d=dx*dx+dy*dy;
      if (d<best){best=d; idx=i;}
    }
    return idx;
  }

  function setClip() {
    ctx.save();
    ctx.beginPath();
    for (const ring of projectedRings) {
      const [x0,y0] = toCanvas(ring[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<ring.length;i++) {
        const [xi,yi] = toCanvas(ring[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.clip('nonzero');
  }
  function drawOutline() {
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#111';
    ctx.beginPath();
    for (const ring of projectedRings) {
      const [x0,y0] = toCanvas(ring[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<ring.length;i++) {
        const [xi,yi] = toCanvas(ring[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.stroke();
  }
  function drawStations() {
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#fff';
    ctx.fillStyle   = '#111';
    for (const [x,y] of stationXY) {
      ctx.beginPath();
      ctx.arc(x,y,2,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }
  }

  async function render() {
    const metric = metricEl.value;
    const res    = parseInt(resEl.value,10);
    const angle  = parseFloat(angleEl.value);
    angleVal.textContent = `${angle|0}°`;
    status.textContent = `Rendering (${metric.toUpperCase()} @ step=${res})…`;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    setClip();

    const W = canvas.clientWidth;
    const H = canvas.clientHeight;

    let x = 0;
    const band = 8*res;
    function step() {
      const xEnd = Math.min(W, x + band);
      for (let xi=x; xi<xEnd; xi+=res) {
        for (let yi=0; yi<H; yi+=res) {
          const idx = (metric==='l1')
            ? nearestIndexL1(xi + 0.5*res, yi + 0.5*res, angle)
            : nearestIndexL2(xi + 0.5*res, yi + 0.5*res);
          ctx.fillStyle = palette[idx % palette.length];
          ctx.fillRect(xi, yi, res, res);
        }
      }
      x = xEnd;
      if (x < W) requestAnimationFrame(step);
      else {
        ctx.restore();
        drawOutline();
        drawStations();
        status.textContent = `Done. ${stationXY.length} stations.`;
      }
    }
    requestAnimationFrame(step);
  }

  // UI
  metricEl.addEventListener('change', () => {
    angleWrap.style.display = (metricEl.value === 'l1') ? 'inline-flex' : 'none';
  });
  angleEl.addEventListener('input', () => { angleVal.textContent = `${angleEl.value}°`; });
  redrawBtn.addEventListener('click', render);

  // Resize/redraw
  function handleResize() {
    resizeCanvasToDisplaySize();
    fitProjectionAndPrecompute();
    render();
  }
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(handleResize, 120);
  });

  // First draw
  metricEl.dispatchEvent(new Event('change'));
  handleResize();
}

main().catch(err => {
  document.getElementById('status').textContent = 'Error: ' + err;
  console.error(err);
});
</script>
</body>
</html>

