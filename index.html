<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Manhattan Voronoi</title>

<style>
  :root {
    --bg:#f8f7f2; --fg:#111; --accent:#0b6;
    --subway-sans: "Helvetica Neue", Helvetica, Arial, "Nimbus Sans",
                   "Liberation Sans", system-ui, sans-serif;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin:0;
    font-family: var(--subway-sans);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    background: var(--bg); color: var(--fg);
    display: grid; grid-template-rows: auto 1fr auto;
  }

  /* Header with controls (title removed from here) */
  header {
    padding: 10px 16px;
    display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
    border-bottom: 1px solid #e5e5e5;
  }
  header > * { font-size: 14px; }
  label { display: inline-flex; align-items: center; gap: 6px; }
  button {
    padding: 6px 10px; border: 1px solid #ccc; background: #fff;
    border-radius: 8px; cursor: pointer;
  }
  button:hover { border-color: var(--accent); }

  /* Map area */
  #container { position: relative; height: 100%; }
  canvas { display:block; width: 100%; height: 100%; background: var(--bg); }


  /* Big stacked title overlay (top-left of the map area) */
  #bigTitle {
    position: absolute;
    top: clamp(12px, 2.5vw, 28px);
    left: clamp(12px, 2.5vw, 28px);
    display: flex; flex-direction: column; align-items: flex-start; gap: 0.04em;
    pointer-events: none; /* so it never blocks clicks/drag */
    line-height: 0.9;
    /* Responsive size: min 42px, scales with viewport, caps at 160px */
    font-size: clamp(21px, 4.5vw, 80px);
    font-weight: 800;  /* bold, like signage */
    letter-spacing: 0.2px;
    color: #111;
    /* subtle outline so text stays legible on any colors */
    text-shadow:
      -1px -1px 0 #fff,
       1px -1px 0 #fff,
      -1px  1px 0 #fff,
       1px  1px 0 #fff,
       0   0 6px #fff;
  }
  #bigTitle span { display:block; }

  /* Footer status */
  #status {
    text-align:center; padding: 8px 12px; font-size: 13px; color:#666;
    border-top: 1px solid #e5e5e5;
  }
</style>
</head>
<body>
  <header>
    <!-- Title removed from header per your request -->
    <label>Dataset:
      <select id="dataset">
        <option value="stations" selected>Railway stations</option>
        <option value="museums">Museums</option>
      </select>
    </label>
    <label>Metric:
      <select id="metric">
        <option value="l1" selected>Manhattan (L1)</option>
        <option value="l2">Euclidean (L2)</option>
      </select>
    </label>
    <label id="angleWrap">L1 angle:
      <input id="angle" type="range" min="-45" max="45" step="1" value="29" />
      <span id="angleVal">29°</span>
    </label>
    <label>Resolution (px):
      <select id="res">
        <option value="2" selected>Fast (2)</option>
        <option value="1">Fine (1)</option>
        <option value="3">Faster (3)</option>
        <option value="4">Fastest (4)</option>
      </select>
    </label>
    <button id="redraw">Redraw</button>
  </header>

  <div id="container">
    <canvas id="c"></canvas>

    <!-- BIG stacked title overlay; change text if you really want “Voroni” -->
    <div id="bigTitle">
      <span>Manhattan</span>
      <span>Voronoi</span>
    </div>
  </div>

  <div id="status">Loading…</div>
  
<script type="module">
import { Delaunay } from "https://cdn.jsdelivr.net/npm/d3-delaunay@6/+esm";

async function main() {
  const status   = document.getElementById('status');
  const canvas   = document.getElementById('c');
  const ctx      = canvas.getContext('2d', { willReadFrequently: false });

  // UI
  const datasetEl = document.getElementById('dataset'); // must exist in your header
  const metricEl  = document.getElementById('metric');
  const angleWrap = document.getElementById('angleWrap');
  const angleEl   = document.getElementById('angle');
  const angleVal  = document.getElementById('angleVal');
  const resEl     = document.getElementById('res');
  const redrawBtn = document.getElementById('redraw');

  // -------- Load data --------
  const [boundaryFC, stationsFC, museumsFC] = await Promise.all([
    fetch('./data/manhattan_boundary.geojson').then(r => r.json()),
    fetch('./data/manhattan_stations.geojson').then(r => r.json()),
    fetch('./data/manhattan_museums.geojson').then(r => r.json()),
  ]);

  // -------- Geo helpers --------
  const R = 6378137; // Web Mercator sphere
  const DEG = Math.PI / 180;

  const projectLonLatToMeters = (lon, lat) => {
    const x = R * lon * DEG;
    const φ = Math.max(Math.min(lat * DEG, Math.PI/2 - 1e-6), -Math.PI/2 + 1e-6);
    const y = R * Math.log(Math.tan(Math.PI/4 + φ/2));
    return [x, y];
  };

  const ringLooksLikeLonLat = (ring) => {
    const n = Math.min(ring.length, 50);
    for (let i=0;i<n;i++) {
      const [a,b] = ring[i];
      if (!(a > -180 && a < 180 && b > -90 && b < 90)) return false;
    }
    return true;
  };

  function largestOuterRing(fc) {
    function ringArea(r) {
      let A=0; for (let i=0,j=r.length-1;i<r.length;j=i++) {
        const [x0,y0]=r[j],[x1,y1]=r[i]; A += x0*y1 - x1*y0;
      } return A/2;
    }
    let best=null, bestA=-Infinity;
    for (const f of fc.features) {
      const g=f.geometry; if (!g) continue;
      if (g.type==='Polygon') {
        const r=g.coordinates[0]; const a=Math.abs(ringArea(r));
        if (a>bestA){bestA=a; best=r;}
      } else if (g.type==='MultiPolygon') {
        for (const poly of g.coordinates) {
          const r=poly[0]; const a=Math.abs(ringArea(r));
          if (a>bestA){bestA=a; best=r;}
        }
      }
    }
    return best || [];
  }

  function pointsLonLatClean(fc) {
    const pts=[];
    for (const f of fc.features) {
      const g=f.geometry; if (!g) continue;
      if (g.type === 'Point') {
        let [a,b] = g.coordinates;
        let lon=a, lat=b;
        // swap if likely lat,lon
        if (!(lon>-180&&lon<180&&lat>-90&&lat<90) && (b>-180&&b<180&&a>-90&&a<90)) {
          lon=b; lat=a;
        }
        // NYC-ish bbox filter
        if (lon>-75 && lon<-72 && lat>40 && lat<41) pts.push([lon,lat]);
      }
    }
    return pts;
  }

  // -------- Boundary & datasets in meters --------
  const boundaryRingRaw = largestOuterRing(boundaryFC);
  const boundaryIsLonLat = ringLooksLikeLonLat(boundaryRingRaw);
  const boundaryRingMeters = boundaryIsLonLat
    ? boundaryRingRaw.map(([lon,lat]) => projectLonLatToMeters(lon,lat))
    : boundaryRingRaw;

  const stationsLonLat = pointsLonLatClean(stationsFC);
  const museumsLonLat  = pointsLonLatClean(museumsFC);

  const stationsMeters = stationsLonLat.map(([lon,lat]) => projectLonLatToMeters(lon,lat));
  const museumsMeters  = museumsLonLat.map(([lon,lat])  => projectLonLatToMeters(lon,lat));

  // -------- Canvas sizing / transforms --------
  function resizeCanvasToDisplaySize(cv) {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = cv.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (cv.width !== w || cv.height !== h) { cv.width = w; cv.height = h; }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS px
  }

  let toCanvas = (xy)=>xy;
  let projectedRing = boundaryRingMeters;

  // Active dataset (starts with stations)
  let currentPointsMeters = stationsMeters;
  let stationXY = [];

  // Neighbor-aware colors
  const MTA_COLORS = [
    '#0062CF', // A/C/E blue
    '#EB6800', // B/D/F/M orange
    '#799534', // G light green
    '#8E5C33', // J/Z brown
    '#F6BC26', // N/Q/R/W yellow
    '#D82233', // 1/2/3 red
    '#009952', // 4/5/6 dark green
    '#9A38A1', // 7 purple
    '#008EB7', // T teal (proposed)
  ];
  let siteColor = []; // color per site index

  function setDataset(kind) {
    currentPointsMeters = (kind === 'museums') ? museumsMeters : stationsMeters;
    fitProjectionAndPrecompute();
  }

  function fitProjectionAndPrecompute() {
    // Use boundary for viewport (fallback: current points if boundary empty)
    const src = projectedRing.length ? projectedRing : currentPointsMeters;
    let minX=+Infinity, minY=+Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const [x,y] of src) {
      if (x<minX) minX=x; if (x>maxX) maxX=x;
      if (y<minY) minY=y; if (y>maxY) maxY=y;
    }
    const pad = 2000; // ~2 km padding
    minX -= pad; maxX += pad; minY -= pad; maxY += pad;

    const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
    const sx = cssW / (maxX - minX);
    const sy = cssH / (maxY - minY);
    const s  = Math.min(sx, sy);
    const ox = (cssW - s*(maxX-minX))/2;
    const oy = (cssH - s*(maxY-minY))/2;

    toCanvas = ([x,y]) => [ ox + s*(x - minX), oy + s*(maxY - y) ];
    stationXY = currentPointsMeters.map(([x,y]) => toCanvas([x,y]));

    computeSiteColors(); // recompute colors whenever points/size change
  }

  // -------- Distance + drawing helpers --------
  const rotate = (x,y,deg) => {
    const t = deg * Math.PI/180, c = Math.cos(t), s = Math.sin(t);
    return [ c*x + s*y, -s*x + c*y ];
  };

  function nearestIndexL1(x,y,deg=0) {
    if (deg) [x,y] = rotate(x,y,deg);
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      let [sx,sy] = stationXY[i];
      if (deg) [sx,sy] = rotate(sx,sy,deg);
      const d = Math.abs(x - sx) + Math.abs(y - sy);
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  function nearestIndexL2(x,y) {
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      const [sx,sy] = stationXY[i];
      const dx = x - sx, dy = y - sy;
      const d = dx*dx + dy*dy;
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  // Build neighbor-aware colors via Delaunay → greedy coloring
  // Build neighbor-aware colors via Delaunay → balanced greedy coloring
function computeSiteColors() {
  const n = stationXY.length;
  siteColor = Array(n).fill(null);
  if (n === 0) return;

  const m = MTA_COLORS.length;
  const colorCounts = Array(m).fill(0); // usage count per palette color
  let cursor = 0;                       // rotates to avoid early-color bias

  const delaunay = Delaunay.from(stationXY);
  const neighbors = Array.from({length:n}, () => new Set());
  for (let i=0; i<n; i++) for (const j of delaunay.neighbors(i)) {
    neighbors[i].add(j); neighbors[j].add(i);
  }

  // Welsh–Powell ordering (high degree first)
  const order = Array.from({length:n}, (_,i)=>i)
    .sort((a,b) => neighbors[b].size - neighbors[a].size);

  for (const v of order) {
    const forbidden = new Set();
    for (const u of neighbors[v]) {
      const c = siteColor[u];
      if (c != null) forbidden.add(c);
    }

    // Build list of allowed color indices
    const allowed = [];
    for (let k = 0; k < m; k++) if (!forbidden.has(k)) allowed.push(k);

    // Pick allowed color with the lowest usage; break ties by rotating start
    let bestIdx = allowed[0], bestCount = Infinity;
    // start from cursor to spread choices across the palette
    for (let t = 0; t < allowed.length; t++) {
      const k = allowed[(t + cursor) % allowed.length];
      const cnt = colorCounts[k];
      if (cnt < bestCount) { bestCount = cnt; bestIdx = k; }
    }

    siteColor[v] = bestIdx;
    colorCounts[bestIdx] += 1;
    cursor = (cursor + 1) % m; // move the tie-breaker forward for next site
  }
}


  function setClip() {
    ctx.save();
    ctx.beginPath();
    if (projectedRing.length) {
      const [x0,y0] = toCanvas(projectedRing[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<projectedRing.length;i++) {
        const [xi,yi] = toCanvas(projectedRing[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.clip('nonzero');
  }

  function drawOutline() {
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#111';
    ctx.beginPath();
    if (projectedRing.length) {
      const [x0,y0] = toCanvas(projectedRing[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<projectedRing.length;i++) {
        const [xi,yi] = toCanvas(projectedRing[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.stroke();
  }

  function drawStations() {
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = '#fff';
    // ctx.fillStyle = '#111'; if you want a black pixel in the middle
    for (const [x,y] of stationXY) {
      ctx.beginPath();
      ctx.arc(x, y, 0.8, 0, Math.PI*2); // compact markers
      ctx.fill();
      ctx.stroke();
    }
  }

  async function render() {
    const which = datasetEl.value;
    const metric = metricEl.value;
    const res = parseInt(resEl.value, 10);
    const angle = parseFloat(angleEl.value);
    angleVal.textContent = `${angle|0}°`;
    status.textContent = `Rendering ${which} (${metric.toUpperCase()} @ step=${res})…`;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    setClip();

    const W = canvas.clientWidth;
    const H = canvas.clientHeight;

    let x = 0;
    const band = 8*res; // columns per frame
    function step() {
      const xEnd = Math.min(W, x + band);
      for (let xi = x; xi < xEnd; xi += res) {
        for (let yi = 0; yi < H; yi += res) {
          const idx = (metric === 'l1')
            ? nearestIndexL1(xi + 0.5*res, yi + 0.5*res, angle)
            : nearestIndexL2(xi + 0.5*res, yi + 0.5*res);

          const colorIdx = siteColor[idx] ?? (idx % MTA_COLORS.length);
          ctx.fillStyle = MTA_COLORS[colorIdx];
          ctx.fillRect(xi, yi, res, res);

        }
      }
      x = xEnd;
      if (x < W) {
        requestAnimationFrame(step);
      } else {
        ctx.restore();
        drawOutline();
        drawStations();
        status.innerHTML = `Done. ${stationXY.length} ${which}. <a href="https://www.mta.info/document/168976" target="_blank" rel="noopener">Color reference</a>.`;
      }
    }
    requestAnimationFrame(step);
  }

  // -------- UI & resize wiring --------
  metricEl.addEventListener('change', () => {
    angleWrap.style.display = (metricEl.value === 'l1') ? 'inline-flex' : 'none';
  });
  angleEl.addEventListener('input', () => {
    angleVal.textContent = `${angleEl.value}°`;
  });
  redrawBtn.addEventListener('click', render);

  datasetEl.addEventListener('change', () => {
    setDataset(datasetEl.value);
    render();
  });

  function resizeAndRedraw() {
    resizeCanvasToDisplaySize(canvas);
    fitProjectionAndPrecompute();
    render();
  }
  let t;
  window.addEventListener('resize', () => {
    clearTimeout(t);
    t = setTimeout(resizeAndRedraw, 80);
  });

  // -------- Initial draw --------
  metricEl.dispatchEvent(new Event('change'));
  setDataset(datasetEl.value || 'stations');   // initialize
  resizeAndRedraw();
}

main().catch(err => {
  document.getElementById('status').textContent = 'Error: ' + err;
  console.error(err);
});
</script>
</body>
</html>

