<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Manhattan Voronoi (L1 / L2)</title>
<style>
  :root { --bg:#f8f7f2; --fg:#111; --accent:#0b6; }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background: var(--bg); color: var(--fg);
    display: grid; grid-template-rows: auto 1fr auto;
  }
  header {
    padding: 10px 16px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
    border-bottom: 1px solid #e5e5e5;
  }
  header > * { font-size: 14px; }
  label { display: inline-flex; align-items: center; gap: 6px; }
  button {
    padding: 6px 10px; border: 1px solid #ccc; background: #fff;
    border-radius: 8px; cursor: pointer;
  }
  button:hover { border-color: var(--accent); }
  #container { position: relative; height: 100%; }
  canvas { display:block; width: 100%; height: 100%; background: var(--bg); }
  #status {
    text-align:center; padding: 8px 12px; font-size: 13px; color:#666;
    border-top: 1px solid #e5e5e5;
  }
</style>
</head>
<body>
  <header>
    <strong>Manhattan Voronoi</strong>
    <label>Metric:
      <select id="metric">
        <option value="l1" selected>Manhattan (L1)</option>
        <option value="l2">Euclidean (L2)</option>
      </select>
    </label>
    <label id="angleWrap">L1 angle:
      <input id="angle" type="range" min="-45" max="45" step="1" value="29" />
      <span id="angleVal">29°</span>
    </label>
    <label>Resolution (px):
      <select id="res">
        <option value="2" selected>Fast (2)</option>
        <option value="1">Fine (1)</option>
        <option value="3">Faster (3)</option>
        <option value="4">Fastest (4)</option>
      </select>
    </label>
    <button id="redraw">Redraw</button>
  </header>

  <div id="container">
    <canvas id="c"></canvas>
  </div>
  <div id="status">Loading…</div>

<script type="module">
/* === tweaks requested === */
const MAP_ROTATE_DEG = -29; // rotate the whole map so Manhattan looks “straight”

async function main() {
  const status = document.getElementById('status');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { willReadFrequently: false });

  // UI
  const metricEl = document.getElementById('metric');
  const angleWrap = document.getElementById('angleWrap');
  const angleEl = document.getElementById('angle');
  const angleVal = document.getElementById('angleVal');
  const resEl = document.getElementById('res');
  const redrawBtn = document.getElementById('redraw');

  // -------- Load data --------
  const [boundaryFC, stationsFC] = await Promise.all([
    fetch('./data/manhattan_boundary.geojson').then(r => r.json()),
    fetch('./data/manhattan_stations.geojson').then(r => r.json())
  ]);

  // -------- Robust GeoJSON helpers --------
  function normalizeLonLat(a, b) {
    const inLon = (x) => x > -180 && x < -60; // longitudes that include NYC
    const inLat = (x) => x > 20 && x < 55;    // latitudes that include NYC
    if (inLon(a) && inLat(b)) return [a,b];
    if (inLon(b) && inLat(a)) return [b,a];
    return [a,b];
  }

  function ringArea(ring) {
    let a = 0;
    for (let i=0, j=ring.length-1; i<ring.length; j=i++) {
      const [x0,y0] = ring[j], [x1,y1] = ring[i];
      a += x0*y1 - x1*y0;
    }
    return a/2;
  }

  function largestOuterRing(featureCollection) {
    let best = null, bestArea = -Infinity;
    for (const f of featureCollection.features) {
      const g = f.geometry;
      if (!g) continue;
      if (g.type === 'Polygon') {
        const ring = g.coordinates[0];
        const area = Math.abs(ringArea(ring));
        if (area > bestArea) { bestArea = area; best = ring; }
      } else if (g.type === 'MultiPolygon') {
        for (const poly of g.coordinates) {
          const ring = poly[0];
          const area = Math.abs(ringArea(ring));
          if (area > bestArea) { bestArea = area; best = ring; }
        }
      }
    }
    return (best || []).map(([a,b]) => normalizeLonLat(a,b));
  }

  function stationsLonLatClean(fc) {
    const pts = [];
    for (const feat of fc.features) {
      const g = feat.geometry;
      if (g?.type === 'Point') {
        const [a,b] = g.coordinates;
        const [lon,lat] = normalizeLonLat(a,b);
        if (lon > -75 && lon < -72 && lat > 40 && lat < 41) pts.push([lon,lat]);
      }
    }
    return pts;
  }

  // -------- Projection & sizing --------
  function mercatorProject(lon, lat) {
    const λ = lon * Math.PI/180;
    const φ = Math.max(Math.min(lat* Math.PI/180, Math.PI/2 - 1e-6), -Math.PI/2 + 1e-6);
    return [λ, Math.log(Math.tan(Math.PI/4 + φ/2))];
  }

  function resizeCanvasToDisplaySize(canvas) {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  const boundaryRingLonLat = largestOuterRing(boundaryFC); // [[lon,lat],...]
  const stationsLonLat     = stationsLonLatClean(stationsFC); // [[lon,lat],...]

  // Work in projected meters-ish coordinates
  const projectedRing = boundaryRingLonLat.map(([lon,lat]) => mercatorProject(lon,lat));
  const stationProj   = stationsLonLat.map(([lon,lat]) => mercatorProject(lon,lat));

  let toCanvas = (xy)=>xy;    // set after fit
  let stationXY = [];         // stations in canvas pixels (rotated)

  function fitProjectionAndPrecompute() {
    // Use station bounds for viewport (fallback to boundary if empty)
    const coordsForBbox = stationProj.length ? stationProj : projectedRing;
    let minX=+Infinity, minY=+Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const [x,y] of coordsForBbox) {
      if (x<minX) minX=x; if (x>maxX) maxX=x;
      if (y<minY) minY=y; if (y>maxY) maxY=y;
    }
    const pad = 0.06; minX -= pad; maxX += pad; minY -= pad; maxY += pad;

    const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
    const sx = cssW / (maxX - minX);
    const sy = cssH / (maxY - minY);
    const s  = Math.min(sx, sy);
    const ox = (cssW - s*(maxX-minX))/2;
    const oy = (cssH - s*(maxY-minY))/2;

    // base mapping (projected → canvas)
    const baseToCanvas = ([x,y]) => [ ox + s*(x - minX), oy + s*(maxY - y) ];

    // rotate map around canvas center
    const cx = cssW / 2, cy = cssH / 2;
    const t  = MAP_ROTATE_DEG * Math.PI / 180;
    const c  = Math.cos(t), s1 = Math.sin(t);
    function rotateAround(px, py) {
      const dx = px - cx, dy = py - cy;
      return [ cx + c*dx - s1*dy, cy + s1*dx + c*dy ];
    }

    toCanvas = (pt) => rotateAround(...baseToCanvas(pt));
    stationXY = stationProj.map(([x,y]) => toCanvas([x,y]));
  }

  // -------- Distance helpers --------
  const palette = Array.from({length: 20}, (_,i) => `hsl(${(i*360/20)|0} 70% 45%)`);

  const rotate = (x,y,deg) => {
    const t = deg * Math.PI/180, c = Math.cos(t), s = Math.sin(t);
    return [ c*x + s*y, -s*x + c*y ];
  };

  function nearestIndexL1(x,y,deg=0) {
    if (deg) [x,y] = rotate(x,y,deg);
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      let [sx,sy] = stationXY[i];
      if (deg) [sx,sy] = rotate(sx,sy,deg);
      const d = Math.abs(x - sx) + Math.abs(y - sy);
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  function nearestIndexL2(x,y) {
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      const [sx,sy] = stationXY[i];
      const dx = x - sx, dy = y - sy;
      const d = dx*dx + dy*dy;
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  // -------- Drawing --------
  function setClip() {
    ctx.save();
    ctx.beginPath();
    if (projectedRing.length) {
      const [x0,y0] = toCanvas(projectedRing[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<projectedRing.length;i++) {
        const [xi,yi] = toCanvas(projectedRing[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.clip('nonzero');
  }

  function drawOutline() {
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#111';
    ctx.beginPath();
    if (projectedRing.length) {
      const [x0,y0] = toCanvas(projectedRing[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<projectedRing.length;i++) {
        const [xi,yi] = toCanvas(projectedRing[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.stroke();
  }

  // smaller station dots (half size)
  function drawStations() {
    ctx.lineWidth = 2;          // was 3
    ctx.strokeStyle = '#fff';
    ctx.fillStyle = '#111';
    for (const [x,y] of stationXY) {
      ctx.beginPath();
      ctx.arc(x, y, 1, 0, Math.PI*2); // was 2
      ctx.fill();
      ctx.stroke();
    }
  }

  async function render() {
    const metric = metricEl.value;
    const res = parseInt(resEl.value, 10);
    const angle = parseFloat(angleEl.value);
    angleVal.textContent = `${angle|0}°`;
    status.textContent = `Rendering (${metric.toUpperCase()} @ step=${res})…`;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    setClip();

    const W = canvas.clientWidth;
    const H = canvas.clientHeight;

    let x = 0;
    const band = 8*res; // columns per frame
    function step() {
      const xEnd = Math.min(W, x + band);
      for (let xi = x; xi < xEnd; xi += res) {
        for (let yi = 0; yi < H; yi += res) {
          const idx = (metric === 'l1')
            ? nearestIndexL1(xi + 0.5*res, yi + 0.5*res, angle)
            : nearestIndexL2(xi + 0.5*res, yi + 0.5*res);
          ctx.fillStyle = palette[idx % palette.length];
          ctx.fillRect(xi, yi, res, res);
        }
      }
      x = xEnd;
      if (x < W) {
        requestAnimationFrame(step);
      } else {
        ctx.restore();
        drawOutline();
        drawStations();
        status.textContent = `Done. ${stationXY.length} stations.`;
      }
    }
    requestAnimationFrame(step);
  }

  // -------- UI & resize wiring --------
  metricEl.addEventListener('change', () => {
    angleWrap.style.display = (metricEl.value === 'l1') ? 'inline-flex' : 'none';
  });
  angleEl.addEventListener('input', () => {
    angleVal.textContent = `${angleEl.value}°`;
  });
  redrawBtn.addEventListener('click', render);

  function handleResize() {
    resizeCanvasToDisplaySize(canvas);
    fitProjectionAndPrecompute();
    render();
  }
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(handleResize, 80);
  });

  // -------- Initial draw --------
  metricEl.dispatchEvent(new Event('change'));
  handleResize();
}

main().catch(err => {
  document.getElementById('status').textContent = 'Error: ' + err;
  console.error(err);
});
</script>
</body>
</html>
