<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Manhattan Voronoi (L1 / L2)</title>
<style>
  :root { --bg:#f8f7f2; --fg:#111; --accent:#0b6; }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background: var(--bg); color: var(--fg);
    display: grid; grid-template-rows: auto 1fr auto;
  }
  header {
    padding: 10px 16px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
    border-bottom: 1px solid #e5e5e5;
  }
  header > * { font-size: 14px; }
  label { display: inline-flex; align-items: center; gap: 6px; }
  button {
    padding: 6px 10px; border: 1px solid #ccc; background: #fff;
    border-radius: 8px; cursor: pointer;
  }
  button:hover { border-color: var(--accent); }
  #container { position: relative; height: 100%; }
  canvas { display:block; width: 100%; height: 100%; background: var(--bg); }
  #status {
    text-align:center; padding: 8px 12px; font-size: 13px; color:#666;
    border-top: 1px solid #e5e5e5;
  }
</style>
</head>
<body>
  <header>
    <strong>Manhattan Voronoi</strong>
    <label>Metric:
      <select id="metric">
        <option value="l1" selected>Manhattan (L1)</option>
        <option value="l2">Euclidean (L2)</option>
      </select>
    </label>
    <label id="angleWrap">L1 angle:
      <input id="angle" type="range" min="-45" max="45" step="1" value="29" />
      <span id="angleVal">29°</span>
    </label>
    <label>Resolution (px):
      <select id="res">
        <option value="2" selected>Fast (2)</option>
        <option value="1">Fine (1)</option>
        <option value="3">Faster (3)</option>
        <option value="4">Fastest (4)</option>
      </select>
    </label>
    <button id="redraw">Redraw</button>
  </header>

  <div id="container">
    <canvas id="c"></canvas>
  </div>
  <div id="status">Loading…</div>

<script type="module">
const MAP_ROTATE_DEG = -29; // rotate whole map so Manhattan looks upright

async function main() {
  const status = document.getElementById('status');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { willReadFrequently: false });

  // UI
  const metricEl = document.getElementById('metric');
  const angleWrap = document.getElementById('angleWrap');
  const angleEl = document.getElementById('angle');
  const angleVal = document.getElementById('angleVal');
  const resEl = document.getElementById('res');
  const redrawBtn = document.getElementById('redraw');

  // ---- Load data ----
  const [boundaryFC, stationsFC] = await Promise.all([
    fetch('./data/manhattan_boundary.geojson').then(r => r.json()),
    fetch('./data/manhattan_stations.geojson').then(r => r.json())
  ]);

  // ---- Geo helpers ----
  const inLon = (x) => x > -180 && x < -60;
  const inLat = (x) => x > 20 && x < 55;
  const normalizeLonLat = (a,b) => (inLon(a)&&inLat(b)) ? [a,b] : (inLon(b)&&inLat(a)) ? [b,a] : [a,b];

  function ringArea(ring){let a=0;for(let i=0,j=ring.length-1;i<ring.length;j=i++){const [x0,y0]=ring[j],[x1,y1]=ring[i];a+=x0*y1-x1*y0;}return a/2;}
  function largestOuterRing(fc){
    let best=null,area=-Infinity;
    for(const f of fc.features||[]){const g=f.geometry;if(!g)continue;
      if(g.type==='Polygon'){const r=g.coordinates[0];const A=Math.abs(ringArea(r));if(A>area){area=A;best=r;}}
      else if(g.type==='MultiPolygon'){for(const p of g.coordinates){const r=p[0];const A=Math.abs(ringArea(r));if(A>area){area=A;best=r;}}}
    }
    return (best||[]).map(([a,b])=>normalizeLonLat(a,b));
  }
  function stationsLonLatClean(fc){
    const pts=[]; for(const f of fc.features||[]){const g=f.geometry;if(g?.type==='Point'){const [a,b]=g.coordinates;const [lon,lat]=normalizeLonLat(a,b);if(lon>-75&&lon<-72&&lat>40&&lat<41) pts.push([lon,lat]);}}
    return pts;
  }

  // ---- Projection ----
  const merc = (lon,lat)=> {
    const λ = lon*Math.PI/180;
    const φ = Math.max(Math.min(lat*Math.PI/180, Math.PI/2-1e-6), -Math.PI/2+1e-6);
    return [λ, Math.log(Math.tan(Math.PI/4 + φ/2))];
  };

  // Data (projected)
  const ringLonLat = largestOuterRing(boundaryFC);
  const ptsLonLat  = stationsLonLatClean(stationsFC);
  const ringProj   = ringLonLat.map(([lon,lat])=>merc(lon,lat));
  const ptsProj    = ptsLonLat.map(([lon,lat])=>merc(lon,lat));

  // Canvas size / DPR
  function resizeCanvasToDisplaySize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // use CSS pixels for drawing
  }

  // Rotation in projected space (so bbox uses rotated geometry)
  function rotateXY([x,y], deg, [cx,cy]){
    const t = deg*Math.PI/180, c=Math.cos(t), s=Math.sin(t);
    const dx=x-cx, dy=y-cy;
    return [ cx + c*dx - s*dy, cy + s*dx + c*dy ];
  }

  // Globals derived from size
  let toCanvas = (xy)=>xy;
  let ringRot = [], ptsRot = [], stationXY = [];

  function fitProjectionAndPrecompute(){
    // Base bbox (unrotated) to get a sensible rotation center
    const src = ptsProj.length ? ptsProj : ringProj;
    let minX=+Infinity,minY=+Infinity,maxX=-Infinity,maxY=-Infinity;
    for(const [x,y] of src){ if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; }
    const cx=(minX+maxX)/2, cy=(minY+maxY)/2;

    // Rotate data first
    ringRot = ringProj.map(p=>rotateXY(p, MAP_ROTATE_DEG, [cx,cy]));
    ptsRot  = ptsProj.map(p=>rotateXY(p,  MAP_ROTATE_DEG, [cx,cy]));

    // Bbox of rotated data (use stations if present)
    const srcR = ptsRot.length ? ptsRot : ringRot;
    minX=+Infinity;minY=+Infinity;maxX=-Infinity;maxY=-Infinity;
    for(const [x,y] of srcR){ if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; }
    const pad=0.06; minX-=pad; maxX+=pad; minY-=pad; maxY+=pad;

    // Build linear map from rotated space to canvas CSS pixels
    const W=canvas.clientWidth, H=canvas.clientHeight;
    const sx=W/(maxX-minX), sy=H/(maxY-minY), s=Math.min(sx,sy);
    const ox=(W - s*(maxX-minX))/2, oy=(H - s*(maxY-minY))/2;

    toCanvas = ([x,y]) => [ ox + s*(x - minX), oy + s*(maxY - y) ];
    stationXY = ptsRot.map(([x,y]) => toCanvas([x,y]));
  }

  // ---- Distance helpers ----
  const palette = Array.from({length: 20}, (_,i)=>`hsl(${(i*360/20)|0} 70% 45%)`);
  const rotL1 = (x,y,deg)=>{ const t=deg*Math.PI/180,c=Math.cos(t),s=Math.sin(t); return [c*x + s*y, -s*x + c*y]; };

  function nearestIndexL1(x,y,deg=0){
    if (deg) [x,y] = rotL1(x,y,deg);
    let best=Infinity, idx=0;
    for (let i=0;i<stationXY.length;i++){
      let [sx,sy]=stationXY[i];
      if (deg) [sx,sy] = rotL1(sx,sy,deg);
      const d = Math.abs(x-sx) + Math.abs(y-sy);
      if (d<best){best=d; idx=i;}
    }
    return idx;
  }
  function nearestIndexL2(x,y){
    let best=Infinity, idx=0;
    for (let i=0;i<stationXY.length;i++){
      const [sx,sy]=stationXY[i], dx=x-sx, dy=y-sy, d=dx*dx+dy*dy;
      if (d<best){best=d; idx=i;}
    }
    return idx;
  }

  // ---- Drawing ----
  function setClip(){
    ctx.save();
    ctx.beginPath();
    if (ringRot.length){
      const [x0,y0]=toCanvas(ringRot[0]); ctx.moveTo(x0,y0);
      for (let i=1;i<ringRot.length;i++){ const [xi,yi]=toCanvas(ringRot[i]); ctx.lineTo(xi,yi); }
      ctx.closePath();
    }
    ctx.clip('nonzero');
  }

  function drawOutline(){
    ctx.lineWidth=3; ctx.strokeStyle='#111'; ctx.beginPath();
    if (ringRot.length){
      const [x0,y0]=toCanvas(ringRot[0]); ctx.moveTo(x0,y0);
      for (let i=1;i<ringRot.length;i++){ const [xi,yi]=toCanvas(ringRot[i]); ctx.lineTo(xi,yi); }
      ctx.closePath();
    }
    ctx.stroke();
  }

  // station dots half size
  function drawStations(){
    ctx.lineWidth=2; ctx.strokeStyle='#fff'; ctx.fillStyle='#111';
    for (const [x,y] of stationXY){ ctx.beginPath(); ctx.arc(x,y,1,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
  }

  async function render(){
    const metric = metricEl.value;
    const res = parseInt(resEl.value,10);
    const angle = parseFloat(angleEl.value);
    angleVal.textContent = `${angle|0}°`;
    status.textContent = `Rendering (${metric.toUpperCase()} @ step=${res})…`;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    setClip();

    const W=canvas.clientWidth, H=canvas.clientHeight;
    let x=0; const band=8*res;
    function step(){
      const xEnd=Math.min(W, x+band);
      for (let xi=x; xi<xEnd; xi+=res){
        for (let yi=0; yi<H; yi+=res){
          const idx = (metric==='l1')
            ? nearestIndexL1(xi+0.5*res, yi+0.5*res, angle)
            : nearestIndexL2(xi+0.5*res, yi+0.5*res);
          ctx.fillStyle = palette[idx % palette.length];
          ctx.fillRect(xi, yi, res, res);
        }
      }
      x=xEnd;
      if (x<W) requestAnimationFrame(step);
      else { ctx.restore(); drawOutline(); drawStations(); status.textContent=`Done. ${stationXY.length} stations.`; }
    }
    requestAnimationFrame(step);
  }

  // ---- Wire up ----
  metricEl.addEventListener('change', ()=>{ angleWrap.style.display=(metricEl.value==='l1')?'inline-flex':'none'; });
  angleEl.addEventListener('input', ()=>{ angleVal.textContent = `${angleEl.value}°`; });
  redrawBtn.addEventListener('click', render);

  function handleResize(){
    resizeCanvasToDisplaySize();
    fitProjectionAndPrecompute();
    render();
  }
  let t; window.addEventListener('resize', ()=>{ clearTimeout(t); t=setTimeout(handleResize,80); });

  // Initial
  metricEl.dispatchEvent(new Event('change'));
  handleResize();
}

main().catch(err => {
  document.getElementById('status').textContent = 'Error: ' + err;
  console.error(err);
});
</script>
</body>
</html>
