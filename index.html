<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Manhattan Voronoi</title>

<style>
  :root {
    --bg:#f8f7f2; --fg:#111; --accent:#0b6;
    --subway-sans: "Helvetica Neue", Helvetica, Arial, "Nimbus Sans",
                   "Liberation Sans", system-ui, sans-serif;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin:0;
    font-family: var(--subway-sans);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    background: var(--bg); color: var(--fg);
    display: grid; grid-template-rows: auto 1fr auto;
  }

  header {
    padding: 10px 16px;
    display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
    border-bottom: 1px solid #e5e5e5;
  }
  header > * { font-size: 14px; }
  label { display: inline-flex; align-items: center; gap: 6px; }
  button {
    padding: 6px 10px; border: 1px solid #ccc; background: #fff;
    border-radius: 8px; cursor: pointer;
  }
  button:hover { border-color: var(--accent); }

  #container { position: relative; height: 100%; }
  canvas { display:block; width: 100%; height: 100%; background: var(--bg); }

  /* Big stacked title overlay (top-left of map area) */
  #bigTitle {
    position: absolute;
    top: clamp(12px, 2.5vw, 28px);
    left: clamp(12px, 2.5vw, 28px);
    display: flex; flex-direction: column; align-items: flex-start; gap: 0.04em;
    pointer-events: none;
    background: var(--bg);
    line-height: 0.9;
    font-size: clamp(40px, 6vw, 140px);
    font-weight: 800;
    letter-spacing: 0.2px;
    color: #111;
  #bigTitle span { display:block; }

  #status {
    text-align:center; padding: 8px 12px; font-size: 13px; color:#666;
    border-top: 1px solid #e5e5e5;
  }
</style>
</head>
<body>
  <header>
    <label>Dataset:
      <select id="dataset">
        <option value="stations" selected>Railway stations</option>
        <option value="museums">Museums</option>
      </select>
    </label>
    <label>Metric:
      <select id="metric">
        <option value="l1" selected>Manhattan (L1)</option>
        <option value="l2">Euclidean (L2)</option>
      </select>
    </label>
    <label id="angleWrap">L1 angle:
      <input id="angle" type="range" min="-45" max="45" step="1" value="0" />
      <span id="angleVal">29°</span>
    </label>
    <label>Resolution (px):
      <select id="res">
        <option value="2" selected>Fast (2)</option>
        <option value="1">Fine (1)</option>
        <option value="3">Faster (3)</option>
        <option value="4">Fastest (4)</option>
      </select>
    </label>
    <button id="redraw">Redraw</button>
  </header>

  <div id="container">
    <canvas id="c"></canvas>
    <div id="bigTitle"><span>Manhattan</span><span>Voronoi</span></div>
  </div>

  <div id="status">Loading…</div>

<script type="module">
import { Delaunay } from "https://cdn.jsdelivr.net/npm/d3-delaunay@6/+esm";

async function main() {
  const status   = document.getElementById('status');
  const canvas   = document.getElementById('c');
  const ctx      = canvas.getContext('2d', { willReadFrequently: false });

  // UI
  const datasetEl = document.getElementById('dataset');
  const metricEl  = document.getElementById('metric');
  const angleWrap = document.getElementById('angleWrap');
  const angleEl   = document.getElementById('angle');
  const angleVal  = document.getElementById('angleVal');
  const resEl     = document.getElementById('res');
  const redrawBtn = document.getElementById('redraw');
  const params = new URLSearchParams(location.search);
  const isPoster = params.has('poster');

  if (isPoster) {
    // 1) Title: right align + scale
    const title = document.getElementById('bigTitle');
    const titleAlign = (params.get('titleAlign') || 'right').toLowerCase();
    const titleScale = parseFloat(params.get('titleScale') || '1.5');

    if (titleAlign === 'right') {
      // move to top-right and right-align the stacked words
      title.style.left = 'auto';
      title.style.right = 'clamp(12px, 2.5vw, 28px)';
      title.style.alignItems = 'flex-end';
      title.style.textAlign = 'right';
    }

    if (!Number.isNaN(titleScale) && titleScale !== 1) {
      // scale the computed font-size (keeps your responsive clamp base)
      const px = parseFloat(getComputedStyle(title).fontSize);
      title.style.fontSize = `${px * titleScale}px`;
    }

      // 2) Smaller pixels: half the normal size => res=1
      // (You can still override via ?res=2 etc. if you want.)
      const resOverride = params.get('res') || '1';
      resEl.value = resOverride;
    }
  // Load data
  const [boundaryFC, stationsFC, museumsFC] = await Promise.all([
    fetch('./data/manhattan_boundary.geojson').then(r => r.json()),
    fetch('./data/manhattan_stations.geojson').then(r => r.json()),
    fetch('./data/manhattan_museums.geojson').then(r => r.json()),
  ]);

  // --- Geo helpers ---
  const R = 6378137, DEG = Math.PI / 180;

  const projectLonLatToMeters = (lon, lat) => {
    const x = R * lon * DEG;
    const φ = Math.max(Math.min(lat * DEG, Math.PI/2 - 1e-6), -Math.PI/2 + 1e-6);
    const y = R * Math.log(Math.tan(Math.PI/4 + φ/2));
    return [x, y];
  };

  const ringLooksLikeLonLat = (ring) => {
    const n = Math.min(ring.length, 50);
    for (let i=0;i<n;i++) {
      const [a,b] = ring[i];
      if (!(a > -180 && a < 180 && b > -90 && b < 90)) return false;
    }
    return true;
  };

  function largestOuterRing(fc) {
    function ringArea(r) {
      let A=0; for (let i=0,j=r.length-1;i<r.length;j=i++) {
        const [x0,y0]=r[j],[x1,y1]=r[i]; A += x0*y1 - x1*y0;
      } return A/2;
    }
    let best=null, bestA=-Infinity;
    for (const f of fc.features) {
      const g=f.geometry; if (!g) continue;
      if (g.type==='Polygon') {
        const r=g.coordinates[0]; const a=Math.abs(ringArea(r));
        if (a>bestA){bestA=a; best=r;}
      } else if (g.type==='MultiPolygon') {
        for (const poly of g.coordinates) {
          const r=poly[0]; const a=Math.abs(ringArea(r));
          if (a>bestA){bestA=a; best=r;}
        }
      }
    }
    return best || [];
  }

  function pointsLonLatClean(fc) {
    const pts=[];
    for (const f of fc.features) {
      const g=f.geometry; if (!g) continue;
      if (g.type === 'Point') {
        let [a,b] = g.coordinates;
        let lon=a, lat=b;
        if (!(lon>-180&&lon<180&&lat>-90&&lat<90) && (b>-180&&b<180&&a>-90&&a<90)) {
          lon=b; lat=a;
        }
        if (lon>-75 && lon<-72 && lat>40 && lat<41) pts.push([lon,lat]);
      }
    }
    return pts;
  }

  // Boundary & datasets in meters
  const boundaryRingRaw   = largestOuterRing(boundaryFC);
  const boundaryIsLonLat  = ringLooksLikeLonLat(boundaryRingRaw);
  const boundaryRingMeters = boundaryIsLonLat
    ? boundaryRingRaw.map(([lon,lat]) => projectLonLatToMeters(lon,lat))
    : boundaryRingRaw;

  const stationsMeters = pointsLonLatClean(stationsFC)
    .map(([lon,lat]) => projectLonLatToMeters(lon,lat));
  const museumsMeters  = pointsLonLatClean(museumsFC)
    .map(([lon,lat]) => projectLonLatToMeters(lon,lat));

  // --- Canvas sizing ---
  function resizeCanvasToDisplaySize(cv) {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = cv.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (cv.width !== w || cv.height !== h) { cv.width = w; cv.height = h; }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS px
  }

  // Rotation in data space (y up). Hard-coded to make Manhattan vertical.
  function rotateCCW(x, y, deg) {
    const t = deg * Math.PI / 180;
    const c = Math.cos(t), s = Math.sin(t);
    return [ c*x - s*y, s*x + c*y ];
  }
  const MAP_ROTATE_DEG = 29;

  let toCanvas = (xy)=>xy;
  let projectedRing = boundaryRingMeters;
  let displayRing = [];     // rotated boundary for drawing/clipping
  let currentPointsMeters = stationsMeters;
  let stationXY = [];

  // MTA palette + balanced greedy coloring (via Delaunay neighbors)
  const MTA_COLORS = [
    '#0062CF', '#EB6800', '#799534', '#8E5C33',
    '#F6BC26', '#D82233', '#009952', '#9A38A1', '#008EB7'
  ];
  let siteColor = [];

  function computeSiteColors() {
    const n = stationXY.length;
    siteColor = Array(n).fill(null);
    if (n === 0) return;

    const m = MTA_COLORS.length;
    const colorCounts = Array(m).fill(0);
    let cursor = 0;

    const delaunay = Delaunay.from(stationXY);
    const neighbors = Array.from({length:n}, () => new Set());
    for (let i=0; i<n; i++) for (const j of delaunay.neighbors(i)) {
      neighbors[i].add(j); neighbors[j].add(i);
    }

    const order = Array.from({length:n}, (_,i)=>i)
      .sort((a,b) => neighbors[b].size - neighbors[a].size);

    for (const v of order) {
      const forbidden = new Set();
      for (const u of neighbors[v]) {
        const c = siteColor[u];
        if (c != null) forbidden.add(c);
      }
      const allowed = [];
      for (let k=0;k<m;k++) if (!forbidden.has(k)) allowed.push(k);

      let bestIdx = allowed[0], bestCount = Infinity;
      for (let t=0;t<allowed.length;t++) {
        const k = allowed[(t + cursor) % allowed.length];
        const cnt = colorCounts[k];
        if (cnt < bestCount) { bestCount = cnt; bestIdx = k; }
      }
      siteColor[v] = bestIdx;
      colorCounts[bestIdx] += 1;
      cursor = (cursor + 1) % m;
    }
  }

  function setDataset(kind) {
    currentPointsMeters = (kind === 'museums') ? museumsMeters : stationsMeters;
    fitProjectionAndPrecompute();
  }

  function fitProjectionAndPrecompute() {
    // Rotate boundary & points in meter space so Manhattan is upright
    const ringRot = projectedRing.map(([x,y]) => rotateCCW(x, y, MAP_ROTATE_DEG));
    const ptsRot  = currentPointsMeters.map(([x,y]) => rotateCCW(x, y, MAP_ROTATE_DEG));

    // Bbox from rotated boundary (fallback to points)
    const src = ringRot.length ? ringRot : ptsRot;
    let minX=+Infinity, minY=+Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const [x,y] of src) {
      if (x<minX) minX=x; if (x>maxX) maxX=x;
      if (y<minY) minY=y; if (y>maxY) maxY=y;
    }
    const pad = 2000; // ~2 km padding
    minX -= pad; maxX += pad; minY -= pad; maxY += pad;

    const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
    const sx = cssW / (maxX - minX);
    const sy = cssH / (maxY - minY);
    const s  = Math.min(sx, sy);
    const ox = (cssW - s*(maxX-minX))/2;
    const oy = (cssH - s*(maxY-minY))/2;

    toCanvas   = ([x,y]) => [ ox + s*(x - minX), oy + s*(maxY - y) ];
    stationXY  = ptsRot.map(([x,y]) => toCanvas([x,y]));
    displayRing = ringRot;

    computeSiteColors();
  }

  // Screen-space rotation used only for L1 distance orientation slider
  const rotateScreen = (x,y,deg) => {
    const t = deg * Math.PI/180, c = Math.cos(t), s = Math.sin(t);
    return [ c*x + s*y, -s*x + c*y ];
  };

  function nearestIndexL1(x,y,deg=0) {
    if (deg) [x,y] = rotateScreen(x,y,deg);
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      let [sx,sy] = stationXY[i];
      if (deg) [sx,sy] = rotateScreen(sx,sy,deg);
      const d = Math.abs(x - sx) + Math.abs(y - sy);
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  function nearestIndexL2(x,y) {
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      const [sx,sy] = stationXY[i];
      const dx = x - sx, dy = y - sy;
      const d = dx*dx + dy*dy;
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  function setClip() {
    ctx.save();
    ctx.beginPath();
    if (displayRing.length) {
      const [x0,y0] = toCanvas(displayRing[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<displayRing.length;i++) {
        const [xi,yi] = toCanvas(displayRing[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.clip('nonzero');
  }

  function drawOutline() {
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#111';
    ctx.beginPath();
    if (displayRing.length) {
      const [x0,y0] = toCanvas(displayRing[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<displayRing.length;i++) {
        const [xi,yi] = toCanvas(displayRing[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.stroke();
  }

  function drawStations() {
    ctx.lineWidth = 2.0;
    ctx.strokeStyle = '#fff';
    for (const [x,y] of stationXY) {
      ctx.beginPath();
      ctx.arc(x, y, 1.2, 0, Math.PI*2); // small, pure-white dots (stroke only)
      ctx.stroke();
    }
  }

  async function render() {
    const which = datasetEl.value;
    const metric = metricEl.value;
    const res = parseInt(resEl.value, 10);
    const angle = parseFloat(angleEl.value);
    angleVal.textContent = `${angle|0}°`;
    status.textContent = `Rendering ${which} (${metric.toUpperCase()} @ step=${res})…`;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    setClip();

    const W = canvas.clientWidth;
    const H = canvas.clientHeight;

    let x = 0;
    const band = 8*res; // columns per frame
    function step() {
      const xEnd = Math.min(W, x + band);
      for (let xi = x; xi < xEnd; xi += res) {
        for (let yi = 0; yi < H; yi += res) {
          const idx = (metric === 'l1')
            ? nearestIndexL1(xi + 0.5*res, yi + 0.5*res, angle)
            : nearestIndexL2(xi + 0.5*res, yi + 0.5*res);

          const colorIdx = siteColor[idx] ?? (idx % MTA_COLORS.length);
          ctx.fillStyle = MTA_COLORS[colorIdx];
          ctx.fillRect(xi, yi, res, res);
        }
      }
      x = xEnd;
      if (x < W) {
        requestAnimationFrame(step);
      } else {
        ctx.restore();
        drawOutline();
        drawStations();
        status.innerHTML = `Done. ${stationXY.length} ${which}. <a href="https://www.mta.info/document/168976" target="_blank" rel="noopener">Color reference</a>.`;
      }
    }
    requestAnimationFrame(step);
  }

  // UI & resize wiring
  metricEl.addEventListener('change', () => {
    angleWrap.style.display = (metricEl.value === 'l1') ? 'inline-flex' : 'none';
  });
  angleEl.addEventListener('input', () => { angleVal.textContent = `${angleEl.value}°`; });
  redrawBtn.addEventListener('click', render);

  datasetEl.addEventListener('change', () => { setDataset(datasetEl.value); render(); });

  function resizeAndRedraw() {
    resizeCanvasToDisplaySize(canvas);
    fitProjectionAndPrecompute();
    render();
  }
  let t;
  window.addEventListener('resize', () => {
    clearTimeout(t);
    t = setTimeout(resizeAndRedraw, 80);
  });

  // Initial draw
  metricEl.dispatchEvent(new Event('change'));
  setDataset(datasetEl.value || 'stations');
  resizeAndRedraw();
}

main().catch(err => {
  document.getElementById('status').textContent = 'Error: ' + err;
  console.error(err);
});
</script>
</body>
</html>

