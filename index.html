<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Manhattan Voronoi (L1 / L2)</title>
<style>
  :root { --bg:#f8f7f2; --fg:#111; --accent:#0b6; }
  body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: var(--bg); color: var(--fg); }
  header { padding: 10px 16px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  header > * { font-size: 14px; }
  label { display: inline-flex; align-items: center; gap: 6px; }
  button { padding: 6px 10px; border: 1px solid #ccc; background: #fff; border-radius: 8px; cursor: pointer; }
  button:hover { border-color: var(--accent); }
  #container { position: relative; }
  canvas {
    display:block;
    /* let it get *big*; use viewport size */
    width: 100vw;
    height: calc(100dvh - 64px); /* fill below header */
    margin: 0 auto 16px auto;
    background: var(--bg);
  }
  #status { text-align:center; padding: 6px 0 12px; font-size: 13px; color:#666; }
</style>
</head>
<body>
  <header>
    <strong>Manhattan Voronoi</strong>
    <label>Metric:
      <select id="metric">
        <option value="l1" selected>Manhattan (L1)</option>
        <option value="l2">Euclidean (L2)</option>
      </select>
    </label>
    <label id="angleWrap">L1 angle:
      <input id="angle" type="range" min="-45" max="45" step="1" value="29" />
      <span id="angleVal">29°</span>
    </label>
    <label>Resolution (px):
      <select id="res">
        <!-- This controls how densely we sample pixels when coloring (1 = every pixel, 2 = every 2nd pixel, etc.) -->
        <option value="2" selected>Fast (2)</option>
        <option value="1">Fine (1)</option>
        <option value="3">Faster (3)</option>
        <option value="4">Fastest (4)</option>
      </select>
    </label>
    <button id="redraw">Redraw</button>
  </header>

  <div id="container">
    <canvas id="c"></canvas>
  </div>
  <div id="status">Loading…</div>

<script type="module">
async function main() {
  const status = document.getElementById('status');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { willReadFrequently: false });

  // UI
  const metricEl = document.getElementById('metric');
  const angleWrap = document.getElementById('angleWrap');
  const angleEl = document.getElementById('angle');
  const angleVal = document.getElementById('angleVal');
  const resEl = document.getElementById('res');
  const redrawBtn = document.getElementById('redraw');

  // -------- Load data --------
  const [boundaryFC, stationsFC] = await Promise.all([
    fetch('./data/manhattan_boundary.geojson').then(r => r.json()),
    fetch('./data/manhattan_stations.geojson').then(r => r.json())
  ]);

  // -------- Helpers (unchanged logic) --------
  const fcToPolysLonLat = (fc) => {
    const polys = [];
    for (const feat of fc.features) {
      const g = feat.geometry;
      if (g.type === 'Polygon') polys.push(g.coordinates[0]);
      if (g.type === 'MultiPolygon') for (const poly of g.coordinates) polys.push(poly[0]);
    }
    return polys;
  };

  const fcToPointsLonLat = (fc) => {
    const pts = [];
    for (const feat of fc.features) {
      if (feat.geometry?.type === 'Point') {
        const [lon,lat] = feat.geometry.coordinates;
        pts.push([lon,lat]);
      }
    }
    return pts;
  };

  function mercatorProject(lon, lat) {
    const λ = lon * Math.PI/180;
    const φ = Math.max(Math.min(lat* Math.PI/180, Math.PI/2 - 1e-6), -Math.PI/2 + 1e-6);
    const x = λ;
    const y = Math.log(Math.tan(Math.PI/4 + φ/2));
    return [x, y];
  }

  // -------- High-DPI canvas setup --------
  function resizeCanvasToDisplaySize(canvas) {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect(); // CSS pixels
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    // Scale drawing by DPR so we can keep using CSS pixel coordinates
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  // -------- Globals that depend on size --------
  const ringsLonLat = fcToPolysLonLat(boundaryFC);
  const stationsLonLat = fcToPointsLonLat(stationsFC);

  let projectedRings = [];        // [[ [x,y], ... ], ...] in Mercator
  let toCanvas = (xy) => xy;      // function set after fit
  let stationXY = [];             // stations in canvas pixels

  function fitProjectionAndPrecompute() {
    // 1) Project boundary to Mercator
    projectedRings = ringsLonLat.map(r => r.map(([lon,lat]) => mercatorProject(lon,lat)));

    // 2) Compute bounds in projected space
    let minX=+Infinity, minY=+Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const ring of projectedRings) {
      for (const [x,y] of ring) {
        if (x<minX) minX=x; if (x>maxX) maxX=x;
        if (y<minY) minY=y; if (y>maxY) maxY=y;
      }
    }
    const pad = 0.04; minX -= pad; maxX += pad; minY -= pad; maxY += pad;

    // 3) Build projected -> canvas transform using *CSS* size
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    const sx = cssW / (maxX - minX);
    const sy = cssH / (maxY - minY);
    const s = Math.min(sx, sy);
    const ox = (cssW - s*(maxX-minX))/2;
    const oy = (cssH - s*(maxY-minY))/2;

    toCanvas = ([x,y]) => {
      const cx = ox + s * (x - minX);
      const cy = oy + s * (maxY - y); // flip Y
      return [cx, cy];
    };

    // 4) Precompute station pixel coords
    stationXY = stationsLonLat.map(([lon,lat]) => toCanvas(mercatorProject(lon,lat)));
  }

  // -------- Distance helpers --------
  const palette = Array.from({length: 20}, (_,i) => `hsl(${(i*360/20)|0} 70% 45%)`);

  const rotate = (x,y,deg) => {
    const t = deg * Math.PI/180, c = Math.cos(t), s = Math.sin(t);
    return [ c*x + s*y, -s*x + c*y ];
  };

  function nearestIndexL1(x,y,deg=0) {
    if (deg) [x,y] = rotate(x,y,deg);
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      let [sx,sy] = stationXY[i];
      if (deg) [sx,sy] = rotate(sx,sy,deg);
      const d = Math.abs(x - sx) + Math.abs(y - sy);
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  function nearestIndexL2(x,y) {
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      const [sx,sy] = stationXY[i];
      const dx = x - sx, dy = y - sy;
      const d = dx*dx + dy*dy;
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  function setClip() {
    ctx.save();
    ctx.beginPath();
    for (const ring of projectedRings) {
      const [x0,y0] = toCanvas(ring[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<ring.length;i++) {
        const [xi,yi] = toCanvas(ring[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.clip('nonzero');
  }

  function drawOutline() {
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#111';
    ctx.beginPath();
    for (const ring of projectedRings) {
      const [x0,y0] = toCanvas(ring[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<ring.length;i++) {
        const [xi,yi] = toCanvas(ring[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.stroke();
  }

  function drawStations() {
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#fff';
    ctx.fillStyle = '#111';
    for (const [x,y] of stationXY) {
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }
  }

  async function render() {
    const metric = metricEl.value;
    const res = parseInt(resEl.value, 10);
    const angle = parseFloat(angleEl.value);
    angleVal.textContent = `${angle|0}°`;
    status.textContent = `Rendering (${metric.toUpperCase()} @ step=${res})…`;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    setClip();

    const W = canvas.clientWidth;
    const H = canvas.clientHeight;

    let x = 0;
    const band = 8*res;
    function step() {
      const xEnd = Math.min(W, x + band);
      for (let xi = x; xi < xEnd; xi += res) {
        for (let yi = 0; yi < H; yi += res) {
          const idx = (metric === 'l1')
            ? nearestIndexL1(xi + 0.5*res, yi + 0.5*res, angle)
            : nearestIndexL2(xi + 0.5*res, yi + 0.5*res);
          ctx.fillStyle = palette[idx % palette.length];
          ctx.fillRect(xi, yi, res, res);
        }
      }
      x = xEnd;
      if (x < W) {
        requestAnimationFrame(step);
      } else {
        ctx.restore();
        drawOutline();
        drawStations();
        status.textContent = `Done. ${stationXY.length} stations.`;
      }
    }
    requestAnimationFrame(step);
  }

  // -------- Wire up UI & resize --------
  metricEl.addEventListener('change', () => {
    angleWrap.style.display = (metricEl.value === 'l1') ? 'inline-flex' : 'none';
  });
  angleEl.addEventListener('input', () => {
    angleVal.textContent = `${angleEl.value}°`;
  });
  redrawBtn.addEventListener('click', render);

  function handleResize() {
    resizeCanvasToDisplaySize(canvas);  // set DPR backing store & context scale
    fitProjectionAndPrecompute();       // recompute transforms for new size
    render();                           // redraw
  }
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(handleResize, 100);
  });

  // -------- Initial draw --------
  metricEl.dispatchEvent(new Event('change'));
  handleResize();
}

main().catch(err => {
  document.getElementById('status').textContent = 'Error: ' + err;
  console.error(err);
});
</script>
</body>
</html>
